# 📢 동적 계획법

### ✔ 네트워크 선 자르기 문제

```
현수는 네트워크 선을 1m, 2m의 길이를 갖는 선으로 자르려고 합니다.
예를 들어 4m의 네트워크 선이 주어진다면
1) 1m+1m+1m+1m
2) 2m+1m+1m
3) 1m+2m+1m
4) 1m+1m+2m
5) 2m+2m 
의 5가지 방법을 생각할 수 있습니다. (2)와 (3)과 (4)의 경우 왼쪽을 기준으로 자르는 위치가 
다르면 다른 경우로 생각한다.
그렇다면 네트워크 선의 길이가 Nm라면 몇 가지의 자르는 방법을 생각할 수 있나요? 

▣ 입력설명
첫째 줄은 네트워크 선의 총 길이인 자연수 N(3≤N≤45)이 주어집니다.

▣ 출력설명
첫 번째 줄에 부분증가수열의 최대 길이를 출력한다.

▣ 입력예제 1 
7

▣ 출력예제 1
21
```



### 1. Bottom-Up

- 논리적 관계를 통한 점화식을 구한다
- 초기값을 설정 후 점화식을 통해 `dp`를 채워나간다

``` python
'''
1. dp를 활용한 방법
선의 길이가 1m 늘어났을 경우 Nm가 된다고 가정해보자
문제의 조건에서 1m와 2m로만 자를 수 있다고 했기 때문에 Nm를 만드는 방법은 2가지가 있다
N - 1m에서 1m를 추가하는 방법과 N - 2m에서 2m를 추가하는 방법
그렇기 때문에 dp[n] = dp[n - 1] + dp[n - 2]라는 점화식이 생성된다
이를 활용하여 문제를 해결 할 수 있다.
'''

N = int(input()) # N: 나누고자하는 총 길이
dp = [0] * (N + 1) # N 길이까지 쪼개는 방법의 수의 누적합
dp[1] = 1 # N = 1일 경우 나눌 수 있는 경우가 1가지(1m)
dp[2] = 2 # N = 2인 경우 나눌 수 있는 경우 2가지(1m + 1m, 2m)
# N이 3인 경우부터는 점화식으로 식을 구할 수 있다
for n in range(3, N + 1):
    dp[n] = dp[n - 1] + dp[n -2]
# print(dp)
# 구하고자 하는 답은 dp[-1]에 존재함
print(dp[-1])
```



### 2. Top-Down(재귀 + 메모이제이션)

- 재귀를 통해 점화식의 관계를 구해나간다(재귀)
- 이미 구해놓은 결과값에 대해서는 저장해놓고 재활용한다(메모이제이션)

```python
def DFS(n):
    # 메모이제이션의 값이 존재할 경우 바로 해당값을 불러온다
    if memo[n]:
        return memo[n]
    else:
        # 초기값 설정
        if n == 1 or n == 2:
            memo[n] = n
            return memo[n]
        # Top-down방식으로 재귀가 형성되어 간다
        else:
            # 결과값이 구해지면 메모이제이션에 저장
            memo[n] = DFS(n - 1) + DFS(n - 2)
            return memo[n]

N = int(input()) # N: 총 길이
memo = [0] * (N + 1) # 메모이제이션을 활용할 리스트
DFS(N)
# print(memo)
print(memo[-1])
```

